#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <Windows.h>
#include <time.h>
#include <conio.h>

#define RED 12
#define BLUE 9
#define GREEN 10
#define YELLOW 14

void textColor(int colorNum);
void gotoxy(int x, int y);
void printInCell(int x, int y, char* text, int price);
void draw_board();
struct deed* init_deeds();
struct player* init_players(int player_cnt);
int roll_dice();
void buy_land(struct player* player, struct deed* land);
void pay_toll(struct player* player, struct deed* land);
void game_start();

struct deed {
    char name[40];      // 토지 이름
    int areaNum;        // 빨초노검 구역
    int ownerNum;       // 0: 없음
    int buildingLevel;  // 건물 레벨
    int price[5];       // 대지, 별장1, 별장2, 빌딩, 호텔 가격
    int toll[5];        // 통행료
    int isCanBuild;     // 건설 가능 여부
};

struct player {
    int color;
    int position;
    int money;
};

struct goldenKey {
    int id;
    char name[50];
    char desc[100];
};

struct deed Deeds[29];
struct player Players[4];

void textColor(int colorNum) {
    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), colorNum);
}

void gotoxy(int x, int y) {
    COORD pos = { x, y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

void printInCell(int x, int y, char* text, int price) {
    char line[2][10 + 1] = { "" };  // 줄바꿈된 텍스트를 저장할 배열
    int len = strlen(text);                        // 텍스트 길이
    int currentLine = 0, currentChar = 0;          // 현재 줄과 문자 위치

    if (!strcmp(text, "황금열쇠")) {
        textColor(6);
    }

    // 문자열을 칸 너비에 맞게 나누기
    for (int i = 0; i < len; i++) {
        line[currentLine][currentChar++] = text[i];
        if (currentChar == 10 || i == len - 1) {
            line[currentLine][currentChar] = '\0'; // 줄 끝에 NULL 추가
            currentLine++;
            currentChar = 0;
            if (currentLine >= 2) break;   // 최대 줄 수 초과 시 중단
        }
    }

    // 나눈 텍스트 출력 (칸 내부에 맞춰 출력)
    for (int i = 0; i < currentLine; i++) {
        if (strlen(text) <= 4 || !price) {
            gotoxy(x, y + i+ 1);
        }
        else {
            gotoxy(x, y + i);                        // 각 줄의 위치 설정
        }
        printf("%s", line[i]);
    }

    // 금액 출력 (칸의 마지막 줄에 배치)
    if(price) {
        gotoxy(x, y + 3);
        printf("%d원", price);
    }
    textColor(15);
}


void draw_board() {
    //맨 윗라인
    gotoxy(0, 0);
    puts("┌──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┐");
    for (int i = 0; i < 4; i++) {
        for (int i = 0; i < 11; i++) {
            printf("│          ");
        }
        puts("│");
    }
    puts("├──────────┼──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┼──────────┤");

    // 중간 라인
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 4; j++) {
            puts("│          │                                                                                                  │          │");
        }
        puts("├──────────┤                                                                                                  ├──────────┤");
    }



    for (int j = 0; j < 4; j++) {
        puts("│          │                                                                                                  │          │");
    }

    // 맨 아랫라인
    puts("├──────────┼──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┬──────────┼──────────┤");
    for (int i = 0; i < 4; i++) {
        for (int i = 0; i < 11; i++) {
            printf("│          ");
        }
        puts("│");
    }
    puts("└──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┴──────────┘");

    for (int i = 0; i < 7; i++) {

    }


    char title_art[12][150] = {
        //"    ■■          ■■      ■■■■■■■■                      ■        ■            ■    ",
        //"    ■■          ■■                  ■■      ■■■■■■    ■        ■■■■■■■■    ",
        //"    ■■■■■■■■■      ■■■■■■■■      ■        ■    ■        ■            ■    ",
        //"    ■■          ■■      ■■                  ■        ■    ■        ■■■■■■■■    ",
        //"    ■■■■■■■■■      ■■                  ■        ■    ■■■■                      ",
        //"                            ■■■■■■■■■    ■        ■    ■■■■■■■■■■■■■■■",
        //"                                                  ■        ■    ■              ■■          ",
        //"■■■■■■■■■■■■■■■■■■■■■■■■  ■        ■    ■        ■■■■■■■■    ",
        //"          ■■                    ■■            ■■■■■■    ■                      ■    ",
        //"          ■■                    ■■                            ■        ■■■■■■■■    ",
        //"          ■■                    ■■                            ■        ■                  ",
        //"          ■■                    ■■                            ■        ■■■■■■■■■  "
        "  ■■     ■■    ■■■■■■■■            ■    ■      ■  ",
        "  ■■     ■■          ■■    ■■■■■■  ■    ■■■■■■■■  ",
        "  ■■■■■■■■■    ■■■■■■■■    ■    ■  ■    ■      ■  ",
        "  ■■     ■■    ■■          ■    ■  ■    ■■■■■■■■  ",
        "  ■■■■■■■■■    ■■          ■    ■  ■■■■            ",
        "               ■■■■■■■■■   ■    ■  ■■■■■■■■■■■■■■■",
        "                           ■    ■  ■       ■■      ",
        "■■■■■■■■■■■■■■■■■■■■■■■■■  ■    ■  ■    ■■■■■■■■  ",
        "      ■■          ■■       ■■■■■■  ■           ■  ",
        "      ■■          ■■               ■    ■■■■■■■■  ",
        "      ■■          ■■               ■    ■          ",
        "      ■■          ■■               ■    ■■■■■■■■■ ",

    }; 

    int title_x=37, title_y=10;
    for (int i = 0; i < 12; i++) {
        gotoxy(title_x, title_y+i);
        puts(title_art[i]);
    }

    char key_art[7][100] = {
        "┌────────────────────────────┐",
        "│  .---.                     │",
        "│ /    |\\________________    │",
        "│ | ()  | ________   _   _)  │",
        "│ \\    |/        | | | |     │",
        "│  `---'         \" - \" |_|   │",
        "└────────────────────────────┘"
    };

    int key_x=47, key_y=40;
    for (int i = 0; i < 7; i++) {
        gotoxy(key_x, key_y + i);
        puts(key_art[i]);
    }


    // (x,y)에서 시작
    // 오른쪽으로 한칸 : (x+11, y)
    // 아래쪽으로 한칸 : (x, y+5)
    
    char names[40][40] = { "출발      <---", "1", "황금열쇠", "1","1","1","1", "황금열쇠", "1","1", "무인도", "1", "황금열쇠", "1","1","1","1", "황금열쇠", "1","1", "사회복지기금 수령처", "1", "황금열쇠", "1","1","1","1","1","1","1","우주여행", "1","1","1","1", "황금열쇠", "1","1", "사회복지기금", "1"};
    int cnt = 0;
    int curr_x = 111, curr_y = 51;
    for (int i = 0; i < 10; i++) {
        if (!strcmp(names[i], "1")) {
            printInCell(curr_x, curr_y, Deeds[cnt].name, 0);
            cnt++;
            curr_x -= 11;
        }
        else {
            printInCell(curr_x, curr_y, names[i], 0);
            curr_x -= 11;
        }
    }

    for (int i = 10; i < 20; i++) {
        if (!strcmp(names[i], "1")) {
            printInCell(curr_x, curr_y, Deeds[cnt].name, 0);
            cnt++;
            curr_y -= 5;
        }
        else {
            printInCell(curr_x, curr_y, names[i], 0);
            curr_y -= 5;
        }
    }

    for (int i = 20; i < 30; i++) {
        if (!strcmp(names[i], "1")) {
            printInCell(curr_x, curr_y, Deeds[cnt].name, 0);
            cnt++;
            curr_x += 11;
        }
        else {
            printInCell(curr_x, curr_y, names[i], 0);
            curr_x += 11;
        }
    }

    for (int i = 30; i < 40; i++) {
        if (!strcmp(names[i], "1")) {
            printInCell(curr_x, curr_y, Deeds[cnt].name, 0);
            cnt++;
            curr_y += 5;
        }
        else {
            printInCell(curr_x, curr_y, names[i], 0);
            curr_y += 5;
        }
    }

    char dice_board_art[13][180] = {
        "┌───────────────────────────────────────────────────────┐",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "│                                                       │",
        "└───────────────────────────────────────────────────────┘",
    };
    curr_x = 34, curr_y = 25;
    for (int i = 0; i < 13; i++) {
        gotoxy(curr_x, curr_y + i);
        puts(dice_board_art[i]);
    }

    

}


struct deed* init_deeds() {
    char names[29][40] = {
    "타이베이", "베이징", "마닐라", "제주도", "싱가포르", "카이로", "이스탄불",
    "아네테", "코펜하겐", "스톡홀름", "콩코드 여객기", "베른", "베를린", "오타와",
    "부에노스 아이레스", "상파울루", "시드니", "부산", "하와이", "리스본", "퀸 엘리자베스 호", "마드리드",
    "도쿄", "컬럼비아호", "파리", "로마", "런던", "뉴욕", "서울"
    };
    int each_area_num[4] = { 7, 7, 8, 7 };
    int ownerNum = 0;
    int buildingLevel = 0;
    int prices[29][5] = { // 구매가 : 토지, 별장, 별장2, 빌딩, 호텔
        {50000, 50000, 100000, 150000, 250000}, {80000, 50000, 100000, 150000, 250000}, {80000, 50000, 100000, 150000, 250000}, {200000}, {100000, 50000, 100000, 150000, 250000}, {100000, 50000, 100000, 150000, 250000}, {120000, 50000, 100000, 150000, 250000},
        {140000, 100000, 200000, 300000, 500000}, {160000, 100000, 200000, 300000, 500000}, {160000, 100000, 200000, 300000, 500000}, {200000}, {180000, 100000, 200000, 300000, 500000}, {180000, 100000, 200000, 300000, 500000}, {200000, 100000, 200000, 300000, 500000},
        {220000, 150000, 300000, 400000, 750000}, {240000, 150000, 300000, 450000, 750000}, {240000, 150000, 300000, 450000, 750000}, {500000}, {260000, 150000, 300000, 450000, 750000}, {260000, 150000, 300000, 450000, 750000}, {300000}, {280000, 150000, 300000, 450000, 750000},
        {300000, 200000, 400000, 600000, 1000000}, {450000}, {320000, 200000, 400000, 600000, 1000000}, {320000, 200000, 400000, 600000, 1000000}, {350000, 200000, 400000, 600000, 1000000}, {350000, 200000, 400000, 600000, 1000000}, {1000000}
    };
    int tolls[29][5] = { // 통행료: 토지, 별장, 별장2, 빌딩, 호텔
        {2000, 10000, 30000, 90000, 250000}, {4000, 20000, 60000, 180000, 450000}, {4000, 20000, 60000, 180000, 450000}, {300000}, {6000, 30000, 90000, 270000, 550000}, {6000, 30000, 90000, 270000, 550000}, {8000, 40000, 100000, 300000, 600000},
        {10000, 50000, 150000, 450000, 750000}, {12000, 60000, 180000, 500000, 900000}, {12000, 60000, 180000, 500000, 900000}, {300000}, {14000, 70000, 200000, 550000, 950000}, {14000, 70000, 200000, 550000, 950000}, {16000, 80000, 220000, 600000, 1000000},
        {180000, 90000, 250000, 700000, 1050000}, {20000, 100000, 300000, 750000, 1100000}, {20000, 100000, 300000, 750000, 1100000}, {600000}, {22000, 110000, 330000, 800000, 1150000}, {22000, 110000, 330000, 800000, 1150000}, {250000}, {24000, 120000, 360000, 850000, 1200000},
        {26000, 130000, 390000, 900000, 1270000}, {300000}, {28000, 150000, 450000, 1000000, 1400000}, {28000, 150000, 450000, 1000000, 1400000}, {35000, 170000, 500000, 1100000, 1500000}, {35000, 170000, 500000, 1100000, 1500000}, {2000000}
    };

    for (int i = 0; i < 29; i++) { // Deeds init
        strncpy(Deeds[i].name, names[i], sizeof(Deeds[i].name));
        Deeds[i].ownerNum = -1; // -1 : 소유자X
        Deeds[i].buildingLevel = 0;
        for (int j = 0; j < 5; j++) {
            Deeds[i].price[j] = prices[i][j];
            Deeds[i].toll[j] = tolls[i][j];
        }
    }

    for (int i = 0; i < 4; i++) { // areaNum 초기화, 0123: 빨초노검
        for (int j = 0; j < each_area_num[i]; j++) {
            Deeds[j].areaNum = i;
        }
    }

    return Deeds;
}

struct player* init_players(int player_cnt) {
    for (int i = 0; i < player_cnt; i++) {
        Players[i].position = 0;
        Players[i].money = 2430000;
    }
    return Players;
}

int pick_golden_key(struct player* player) {
    printf("1");
}

int roll_dice() {
    int dice = (rand() % 6) + 1;

    return dice;
}
void message(int x, int y, char text[60]) {
    gotoxy(x, y);
    puts(text);
}

void game_start() {
    srand(time(NULL));
    system("cls");
    int player_cnt;
    int curr_turn = 0;
    char key;
    int curr_arrow_pos = 0;

    Sleep(10);
    init_deeds();
    char names[40][40] = { "출발      <---", "1", "황금열쇠", "1","1","1","1", "황금열쇠", "1","1", "무인도", "1", "황금열쇠", "1","1","1","1", "황금열쇠", "1","1", "사회복지기금 수령처", "1", "황금열쇠", "1","1","1","1","1","1","1","우주여행", "1","1","1","1", "황금열쇠", "1","1", "사회복지기금", "1" };

    draw_board();

    ////////////player_cnt에  몇 명 참가했는지 서버에서 받기
    message(140, 30, "몇명이서 왔어?");
    message(140, 31, "[2] [3] [4]");
    while (1) {
        key = _getch();
        player_cnt = key - 48;
        if (!(player_cnt >= 2 && player_cnt <= 4)) {
            message(140, 32, "올바르지 않음!");
        }
        else {
            printf("%d", player_cnt);
            break;
        }
    }
    /////////////////////////////

    struct player * Players = init_players(player_cnt);

    system("cls");
    draw_board();

    int my_color = 0; // 0 : 빨 | 1 : 파 | 2: 초 | 3 : 노
    int dice1, dice2;

    while (1) {
        if (curr_turn == my_color) {
            message(140, 30, "주사위 굴리기 [k]");
            key = _getch();
            if (key == 'k') {
                dice1 = roll_dice(); // 주사위 굴린 후 제일 큰 숫자가 첫번째 턴
                                    // 정보 보내면 됨
                dice2 = roll_dice();
                gotoxy(35, 26);
                printf("%d %d", dice1, dice2);

                break;
            }
            else {
                message(140, 32, "올바르지 않은 키");
            }
        }
        else {
            message(140, 30, "자신의 턴이 올 때 까지 기다려주세요");
        }
    }
    

    /*
    *
    * 턴이 다 결정 되면 각 턴에 따라서 주사위 굴리기
    * 
    * 서버에서 턴이 바뀐걸 보내주면, 자기 번호랑 체크해서 일치하면 주사위 굴리게 하고, 아니면 기다리게하기
    */

    //system("cls");
    //draw_board();

    curr_turn = 0;

    while (1) {
        
        gotoxy(140, 30);
        printf("현재 Player%d님의 차례입니다.", curr_turn);
        if (GetAsyncKeyState(VK_LEFT)) {
            if (0 <= curr_arrow_pos && curr_arrow_pos <= 9) {
                curr_arrow_pos += 1;
            }
            draw_board();
        }








        if (curr_turn == my_color) {
            message(140, 31, "주사위 굴리기 [k]");
            key = _getch();
            if (key == 'k') {
                dice1 = roll_dice(); // 주사위 굴린 후 제일 큰 숫자가 첫번째 턴
                dice2 = roll_dice();
                // 정보 보내면 됨
                gotoxy(35, 26);
                printf("%d %d", dice1, dice2);
                
                // 굴린 후에는 턴 변경
                curr_turn += 1; // 임시
                if (curr_turn == 4) curr_turn = 0;
                // 
                break;
            }
            else {
                message(140, 32, "올바르지 않은 키");
            }
        }
        else {
            message(140, 30, "자신의 턴이 올 때 까지 기다려주세요");
        }

        
    }

    
    
    
    /*
    while (1) {
        struct Player* current = &Players[turn];
        printf("\n%s의 차례입니다.\n", current->name);

        int dice = roll_dice();
        printf("주사위를 굴려 %d가 나왔습니다!\n", dice);

        current->position = (current->position + dice) % 1000;
        struct deed* currentLand = &Deeds[current->position];
        printf("%s가 %s에 도착했습니다.\n", current->name, currentLand->name);

        if (currentLand->ownerNum == -1) {
            printf("%s를 구매하시겠습니까? (1: 예, 0: 아니오): ", currentLand->name);
            int choice;
            scanf("%d", &choice);
            if (choice == 1) {
                buy_land(current, currentLand);
            }
        }
        else {
            pay_toll(current, currentLand);
        }

        if (current->money <= 0) {
            printf("%s가 파산했습니다! 게임 종료.\n", current->name);
            break;
        }

        turn = (turn + 1) % 4;
    }*/

    gotoxy(60, 60);
}
void set_fullscreen() {
    system("mode con: cols=1000 lines=80");  // 윈도우 cmd 창 크기를 설정 (전체화면처럼 보이게)
}

int main() {
    set_fullscreen();
    game_start();
    system("pause");
    gotoxy(60, 60);
}


/*
void buy_land(struct player* player, struct deed* land) {
    if (land->ownerNum == -1) { // 소유자가 없을 때만 구매 가능
        if (player->money >= land->price[0]) {
            player->money -= land->price[0];
            land->ownerNum = player - player;
            printf("%s가 %s를 구매했습니다!\n", player->name, land->name);
        }
        else {
            printf("자금이 부족합니다!\n");
        }
    }
    else {
        printf("이미 다른 플레이어가 소유하고 있습니다.\n");
    }
}

void pay_toll(struct player* player, struct deed* land) {
    if (land->ownerNum != player - player && land->ownerNum != -1) {
        int toll = land->toll[land->buildingLevel];
        player->money -= toll;
        player[land->ownerNum].money += toll;
        printf("%s가 %s의 통행료 %d원을 지불했습니다!\n", player->name, land->name, toll);
    }
}*/
